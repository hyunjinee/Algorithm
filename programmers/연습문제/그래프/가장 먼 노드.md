# â­ï¸ ê°€ì¥ ë¨¼ ë…¸ë“œ

[ë¬¸ì œ ë³´ëŸ¬ê°€ê¸°](https://programmers.co.kr/learn/courses/30/lessons/49189)

## ğŸ“ ì„¤ê³„

ê°€ì¥ ë©€ë¦¬ ë–¨ì–´ì§„ ë…¸ë“œë€ ìµœë‹¨ ê²½ë¡œë¡œ ì´ë™ í–ˆì„ ë•Œ ê°„ì„ ì˜ ê°œìˆ˜ê°€ ê°€ì¥ ë§ì€ ë…¸ë“œë¥¼ ì˜ë¯¸í•œë‹¤.
bfsë¡œ í•œì¹¸ í•œì¹¸ì”© ë‚´ë ¤ê°ˆ ë•Œ íì— ë“¤ì–´ìˆëŠ” ë…¸ë“œì˜ ê°œìˆ˜ë¥¼ ì„¸ë†“ê³  ê·¸ ê²ƒì„ ì´ìš©í•©ë‹ˆë‹¤.

```py
from collections import deque, defaultdict

def solution(n, edge) :
  answer = 0
  graph = defaultdict(list)
  visited= [0] * (n+1)
  for e in edge:
    graph[e[0]].append(e[1])
    graph[e[1]].append(e[0])
  q = deque()
  q.append(1)
  visited[1] = 1
  while q:
    l = len(q)
    for _ in range(l) :

      x = q.popleft()
      for v in graph[x]:
        if visited[v] == 0:
          q.append(v)
          visited[v] = 1
  return l
```

```js
function solution(n, edges) {
  // make adjacent list
  const adjList = edges.reduce((G, [from, to]) => {
    G[from] = (G[from] || []).concat(to)
    G[to] = (G[to] || []).concat(from)
    return G
  }, {})

  // do BFS
  const queue = [1]
  const visited = { 1: true }
  const dist = { 1: 0 }
  while (queue.length > 0) {
    const node = queue.shift()

    if (adjList[node]) {
      adjList[node].forEach((n) => {
        if (!visited[n]) {
          queue.push(n)
          visited[n] = true
          const d = dist[node] + 1
          if (dist[n] == undefined || d < dist[n]) {
            dist[n] = d
          }
        }
      })
    }
  }

  const dists = Object.values(dist)
  const maxDist = Math.max(...dists)
  return dists.filter((d) => d == maxDist).length
}
```

## âœ… í›„ê¸°

// ìƒˆë¡­ê²Œ ì•Œê²Œ ë˜ì—ˆê±°ë‚˜ ê³µìœ  í•´ì„œ ì•Œê²Œëœ ì 
// ê³ ìƒí•œ ì 

ì–´ë–»ê²Œ í•˜ë©´ bfsë¡œ ê°€ì¥ ë©€ë¦¬ ë–¨ì–´ì§„ ë…¸ë“œë¥¼ ì…€ ìˆ˜ ìˆì„ê¹Œ ê³ ë¯¼ì„ ë§ì´ í•˜ê²Œ í•´ì¤€ ë¬¸ì œì…ë‹ˆë‹¤.
